---
title: 回调函数的this丢失
date: 2017-12-26 22:57:35
categories:
- front-end
- JS
- this
tags:
- JS
- this
- function
---
在学习this的时候有参考《你不知道的JavaScript（上）》中解释this的部分。该书中对于this的指向有这么一条基本准则：
> 每个函数的this是在调用时被绑定的，完全取决于函数的调用位置（也就是函数的调用方法）。
<!-- more -->
紧接着，书中引出调用位置和调用栈的概念。
```javascript
function baz() {
    debugger;
    //当前调用栈：baz
    //当前调用位置：global
    console.log("baz");
    bar();//bar的调用位置
}
function bar() {
    //当前调用栈：baz -> `<bar
    //当前调用位置：baz
    console.log("bar");
    foo();//foo的调用位置
}
function foo() {
    //当前调用栈：baz -> bar -> foo
    //当前调用位置：bar
    console.log("foo");
}
baz();//baz的调用位置
```
为了验证这条准则的正确性，通过debugger单步测试程序，分别观察call stack和&lt;this>的指向。发现结果是&lt;this>的指向全部指向global（即window）。<br>
后来发现其实应该是我对于绑定理解的错误。&lt;this>的指向确实是在调用位置被绑定的，但是**并不是**说指向调用位置。<br>
关于this的绑定大概可以分以下几种类型：
1. 默认绑定（在非严格模式下指向global，而在严格模式下指向为undefined）。在代码中，函数直接使用不带任何修饰的函数引用进行调用，此时使用默认绑定，无法使用其他规则。（以上代码中回调函数是一个不带任何修饰的函数调用，所以this的指向为默认绑定）。
2. 隐式调用（当函数引用上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象）。常见的情况类似`
obj.foo();`这种情况。
3. 显示绑定（在某个对象上强制调用函数，常见的情况有使用`call(..)`，`apply(..)`，`bind(..)`）。函数被绑定之后不能再次改变它的this。
4. new绑定（通过new操作符`new foo(obj)`生成的函数。）。new操作符的步骤分别为 a.创建一个全新的对象; b.该对象执行[[原型]]连接; c.该新对象被绑定到函数调用的this; d.如果函数没有返回对象，new表达式中的函数会自动返回这个新对象。

以上四种绑定优先级为：new>显示>隐式>默认。<br>
但是也会有例外的时候，最典型的一个例子就比如ES6新加的箭头函数。如果出现这类情况，箭头函数会捕获调用时函数的this（继承外层函数调用的this绑定）。一旦绑定this，箭头函数的绑定就无法被修改，new也不例外。该方法属于此法作用域的风格。<br>
另外，在调用中可能无意使用默认绑定规则，这将可能会导致全局变量被无预期的修改，所以需要使用一个空对象如：`ø = Object.create(null)`来保护全局对象。
